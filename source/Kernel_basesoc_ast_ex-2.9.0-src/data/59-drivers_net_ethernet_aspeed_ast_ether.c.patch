--- linux/drivers/net/ethernet/aspeed/ast_ether.c	2015-09-14 13:50:29.650994689 +0800
+++ linux/drivers/net/ethernet/aspeed/ast_ether.c.new	2015-09-14 13:50:13.343995593 +0800
@@ -60,6 +60,93 @@
 static void ast_ether_free_rx_buf(struct net_device *dev);
 //int phy_ad = 0 ;
 
+// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+#ifdef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+#define BORADCAST_MSG_ENABLED 0
+#define BORADCAST_CHECKING_NUM 3840
+#define TIME_4K (HZ*BORADCAST_CHECKING_NUM/4000)
+#define TIME_6K (HZ*BORADCAST_CHECKING_NUM/6000)
+#define TIME_8K (HZ*BORADCAST_CHECKING_NUM/8000)
+#define TIME_10K (HZ*BORADCAST_CHECKING_NUM/10000)
+#define FILTER_TIME_4K (TIME_4K * 1 / 4)
+#define FILTER_TIME_6K (TIME_6K * 2 / 3)
+#define FILTER_TIME_8K (TIME_8K * 3 / 2)
+#define FILTER_TIME_10K (TIME_10K * 4 / 1)
+int filter_on_time =  0;
+#endif
+
+static unsigned int trans_busy[AST_ETHER_USE_NUM] = {0};
+static unsigned long lasttbjiffy[AST_ETHER_USE_NUM] = {0};
+static unsigned int pktlost_count[AST_ETHER_USE_NUM] = {0};
+static unsigned long lastjiffy[AST_ETHER_USE_NUM] = {0};
+static unsigned long lastjiffycount[AST_ETHER_USE_NUM] = {0};
+static unsigned long firstbcjiffy[AST_ETHER_USE_NUM] = {0};
+static struct timer_list bcs_timer[AST_ETHER_USE_NUM];
+static struct timer_list update_mac_timer[AST_ETHER_USE_NUM];
+
+static void broadcast_storm_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+
+#ifndef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+	if ((lastjiffy[dev->dev_id] != 0) && ((jiffies - lastjiffy[dev->dev_id]) >= (2 * HZ))) {
+		unsigned int ioaddr = dev->base_addr;
+
+		printk("%s: Enable RX_HT, RX_MULTIPKT, RX_BROADPKT\n", dev->name);
+		lastjiffy[dev->dev_id] = 0;
+		lastjiffycount[dev->dev_id] = 0;
+		outl(inl(ioaddr + AST_ETHER_MACCR) | MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN, ioaddr + AST_ETHER_MACCR);
+	}
+	bcs_timer[dev->dev_id].expires = jiffies + (1 * HZ);
+	add_timer(&bcs_timer[dev->dev_id]);
+#else
+	if ((lastjiffy[dev->dev_id] != 0) && ((jiffies - lastjiffy[dev->dev_id]) >= (filter_on_time))) {
+		unsigned int ioaddr = dev->base_addr;
+		if (BORADCAST_MSG_ENABLED)
+			printk("%s: Enable Broadcast\n", dev->name);
+		lastjiffy[dev->dev_id] = 0;
+		lastjiffycount[dev->dev_id] = 0;
+		outl(inl(ioaddr + AST_ETHER_MACCR) | MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN, ioaddr + AST_ETHER_MACCR);
+
+		filter_on_time = 0;
+	}
+
+	bcs_timer[dev->dev_id].expires = jiffies + (HZ/10);
+	add_timer(&bcs_timer[dev->dev_id]);
+#endif
+// --- Quanta Chin-Te added 20150910
+}
+
+static void init_bcs_timer(struct net_device *dev)
+{
+	init_timer(&bcs_timer[dev->dev_id]);
+	bcs_timer[dev->dev_id].data = (unsigned long)dev;
+	bcs_timer[dev->dev_id].function = broadcast_storm_timer;
+	bcs_timer[dev->dev_id].expires = jiffies + (1 * HZ);
+	add_timer(&bcs_timer[dev->dev_id]);
+}
+
+static void aspeed_mac_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+
+	outl(0xffffffff, dev->base_addr + AST_ETHER_TXPD); /* Trigger an Tx Poll demand */
+	update_mac_timer[dev->dev_id].expires = jiffies + (1 * HZ);
+	add_timer(&update_mac_timer[dev->dev_id]);
+}
+
+static void init_aspeed_mac_timer(struct net_device *dev)
+{
+	init_timer(&update_mac_timer[dev->dev_id]);
+	update_mac_timer[dev->dev_id].data = (unsigned long)dev;
+	update_mac_timer[dev->dev_id].function = aspeed_mac_timer;
+	update_mac_timer[dev->dev_id].expires = jiffies + (1 * HZ);
+	add_timer(&update_mac_timer[dev->dev_id]);
+}
+#endif
+// --- Quanta
+
 static void ast_ether_get_hardware_addr(struct net_device* dev)
 {
 	memcpy(dev->dev_addr, enetaddr[dev->dev_id], ETH_ALEN);
@@ -144,12 +231,37 @@
 
 	priv->phy_rev = (reg_val & 0x000F); /* Revision[5:0] in ID_LO[3:0] */
 
+// Quanta start
+//printk(">>>>> phy_oui= %x\n", priv->phy_oui);
+// Quanta end
 	switch (priv->phy_oui) {
 	case MARVELL_88E1111_OUI:
 	case BROADCOM_BCM5221_OUI:
 	case BROADCOM_BCM5241_OUI:
 	case MICREL_KSZ80X1_OUI:
 	case REALTEK_RTL82X1X_OUI:
+        /* S4E for LED configuration */
+        /* switch to extend page44, reg31 = 0x0007 */
+        ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0007);
+        /* reg30 = 0x002c (44) */
+        ast_ether_phy_write_register(dev, priv->phy_addr, 30, 0x002c);
+        /* LED0 is for activity reg26 bit 4 = 1*/
+        /* LED1 is 100M LED reg28 bit5 = 1, other bits = 0. */
+        /* LED2 is 1000M LED reg28 bit10 =1, other bits = 0. */
+        reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 28);
+        reg_val = reg_val & 0xF000;
+        reg_val = reg_val | 0x0420;
+        ast_ether_phy_write_register(dev, priv->phy_addr, 28, reg_val);
+
+        reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 26);
+        reg_val = reg_val & 0xFF8F;
+        reg_val = reg_val | 0x0010;
+        ast_ether_phy_write_register(dev, priv->phy_addr, 26, reg_val);
+
+        /* switch back to page 0, reg31=0x0000 */
+        ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0000);
+	
+	  /* S4E for LED configuration end */
 		break;
    case BROADCOM_BCM54612E_OUI: 
     	/* enable expand reg and CLK125 */ 
@@ -161,6 +273,13 @@
     	ast_ether_phy_write_register(dev, priv->phy_addr, 0x1C, 0x8c00); 
     	ast_ether_phy_write_register(dev, priv->phy_addr, 0x18, 0xf0e7); 
     	break; 	
+// Quanta start
+// LAN9303 got phy ID = 0x3fffff, why?
+   case SMSC_LAN9303_OUI:
+// Quanta TBD       case 0x3fffff:
+printk(">>>>> Phy Identified : SMSC_LAN9303_OUI\n");
+       break;
+// Quanta end
 	default:
 		priv->phy_oui = 0; /* not supported PHY or NC-SI */
 		break;
@@ -357,6 +476,34 @@
 					break;
 				}
 				break;
+// Quanta start
+			case SMSC_LAN9303_OUI:
+// Quanta TBD           case 0x3fffff:
+				reg_val = ast_ether_phy_read_register(dev, 0, SMSC_LAN9303_REG_SPECIAL_CONTROL_STATUS);
+				switch ((reg_val & SMSC_LAN9303_REG_STATUS_MASK) >> SMSC_LAN9303_REG_STATUS_SHIFT) {
+				case SMSC_LAN9303_REG_STATUS_HALF_10:
+					duplex = PHY_DUPLEX_HALF;
+					speed = PHY_SPEED_10M;
+					break;
+				case SMSC_LAN9303_REG_STATUS_HALF_100:
+					duplex = PHY_DUPLEX_HALF;
+					speed = PHY_SPEED_100M;
+					break;
+				case SMSC_LAN9303_REG_STATUS_FULL_10:
+					duplex = PHY_DUPLEX_FULL;
+					speed = PHY_SPEED_10M;
+					break;
+				case SMSC_LAN9303_REG_STATUS_FULL_100:
+					duplex = PHY_DUPLEX_FULL;
+					speed = PHY_SPEED_100M;
+					break;
+				default:
+					duplex = PHY_DUPLEX_FULL;
+					speed = PHY_SPEED_100M;
+					break;
+				}
+				break;
+// Quanta end
 			default:
 				speed = PHY_SPEED_100M;
 				duplex = 1;
@@ -743,6 +890,11 @@
 			wmb();
 			priv->rx_desc[entry].status &= RX_DESC_EDORR; /* clear all field except EDORR, return ownership to hardware */
 		}
+		// Quanta ---
+		else {
+			priv->rx_desc[entry].status &= RX_DESC_EDORR; /* clear all field except EDORR, return ownership to hardware */
+		}
+		// --- Quanta
 		priv->dirty_rx ++;
 	}
 }
@@ -756,10 +908,11 @@
     priv->cur_rx = 0;
 	priv->dirty_rx = 0;
 	for (i = 0; i < RX_DES_NUM; i++) {
-		priv->rx_desc[i].status = 0;
+		priv->rx_desc[i].status = RX_DESC_RXPKT_RDY;  //= 0;  // Quanta
 		wmb();		/* Make sure adapter sees owner change */
 		if (priv->rx_skbuff[i]) {
-            dma_unmap_single(NULL, priv->rx_skb_dma[i], priv->rx_skbuff[i]->len, DMA_TO_DEVICE);
+            //dma_unmap_single(NULL, priv->rx_skb_dma[i], priv->rx_skbuff[i]->len, DMA_TO_DEVICE);  // Quanta
+            dma_unmap_single(NULL, priv->rx_skb_dma[i], RX_BUF_SIZE, DMA_FROM_DEVICE);              // Quanta
             dev_kfree_skb_irq(priv->rx_skbuff[i]);
 
 		}
@@ -795,8 +948,13 @@
 	unsigned int ioaddr = dev->base_addr;
 	unsigned int reg_value;
 #endif
+	// Quanta start
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	unsigned int ioaddr = dev->base_addr;
+#endif
+	// Quanta end
 
-	has_error = 0;
+	//has_error = 0;  // Quanta comment it
 	has_first = 0;
 
 	while ((priv->dirty_rx + RX_DES_NUM) != priv->cur_rx) {
@@ -805,6 +963,7 @@
 		if (!(status & RX_DESC_RXPKT_RDY)) /* owned by hardware */
             break;
 
+		has_error = 0;  // Quanta
 		if (status & RX_DESC_FRS) { /* first frame of packet, check error */
 			has_first = 1;
 
@@ -833,18 +992,27 @@
 #endif
 		}
 
-		skb = priv->rx_skbuff[entry];
+		// Quanta start
+		/*skb = priv->rx_skbuff[entry];
 		dma_unmap_single(NULL, priv->rx_skb_dma[entry], RX_BUF_SIZE, DMA_FROM_DEVICE);
 		priv->rx_skbuff[entry] = NULL;
-		priv->rx_skb_dma[entry] = 0;
+		priv->rx_skb_dma[entry] = 0;*/
+		// Quanta end
 
 		if (has_error) {
 			if (status & RX_DESC_CRC_ERR)
 				priv->stats.rx_crc_errors ++;
 			if (status & RX_DESC_FIFO_FULL)
 				priv->stats.rx_fifo_errors ++;
-			kfree_skb(skb);
+			//kfree_skb(skb);  //Quanta comment it
 		} else {
+			// Quanta ---
+			skb = priv->rx_skbuff[entry];
+			dma_unmap_single(NULL, priv->rx_skb_dma[entry], RX_BUF_SIZE, DMA_FROM_DEVICE);
+			priv->rx_skbuff[entry] = NULL;
+			priv->rx_skb_dma[entry] = 0;
+			// --- Quanta
+
 			pkt_len = (status & RX_DESC_VDBC) - 4; /* Omit the four octet CRC from the length. */
 			if (pkt_len > 1518) {
 				printk(KERN_WARNING "%s: Bogus packet size of %d (%#x).\n", dev->name, pkt_len, pkt_len);
@@ -859,6 +1027,70 @@
 #ifdef CONFIG_ASTMAC100_NAPI
 			netif_receive_skb(skb);
 #else
+			// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+			if ((skb->data != NULL) && (pkt_len > 20)) {
+				if (skb->pkt_type == PACKET_BROADCAST || skb->pkt_type == PACKET_MULTICAST) {
+					lastjiffycount[dev->dev_id]++;
+					if (lastjiffycount[dev->dev_id] == 1)
+						firstbcjiffy[dev->dev_id] = jiffies;
+				} else {
+#ifndef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+					lastjiffycount[dev->dev_id] = 0;
+#endif
+				}
+
+#ifndef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+				if (lastjiffycount[dev->dev_id] >= 5000) {
+					if ((jiffies - firstbcjiffy[dev->dev_id]) < HZ) {
+						printk("%s: Disable RX_HT, RX_BROADPKT\n", dev->name);
+						outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+							ioaddr + AST_ETHER_MACCR);
+						lastjiffy[dev->dev_id] = jiffies;
+					}
+					lastjiffycount[dev->dev_id] = 0;
+				}
+#else
+				if (lastjiffycount[dev->dev_id] >= BORADCAST_CHECKING_NUM) {
+					if ((jiffies - firstbcjiffy[dev->dev_id]) < TIME_10K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[dev->dev_id] = jiffies;
+							filter_on_time  = FILTER_TIME_10K;
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 10K broadcast PPS\n", dev->name);
+					}
+					else if ((jiffies - firstbcjiffy[dev->dev_id]) < TIME_8K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[dev->dev_id] = jiffies;
+							filter_on_time  = FILTER_TIME_8K;
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 8K broadcast PPS\n", dev->name);
+					}
+					else if ((jiffies - firstbcjiffy[dev->dev_id]) < TIME_6K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[dev->dev_id] = jiffies;
+							filter_on_time  = FILTER_TIME_6K;
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 6K broadcast PPS\n", dev->name);
+					}
+					else if ((jiffies - firstbcjiffy[dev->dev_id]) < TIME_4K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[dev->dev_id] = jiffies;
+							filter_on_time  = FILTER_TIME_4K;
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 4K broadcast PPS\n", dev->name);
+					}
+					lastjiffycount[dev->dev_id] = 0;
+				}
+#endif
+			}
+#endif // end CONFIG_QUANTA_BROADCAST_STORM
+			// --- Quanta
+
 			netif_rx(skb);
 #endif
 	
@@ -883,6 +1115,19 @@
 		outl(reg_value, ioaddr + AST_ETHER_IER);
 	} 
 #endif
+
+	// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	if (lastjiffy[dev->dev_id] != 0)
+		return;
+	if ((trans_busy[dev->dev_id] == 1) && ((jiffies - lasttbjiffy[dev->dev_id]) > (4 * HZ))) {
+		outl(inl(ioaddr + AST_ETHER_IER) | ISR_RXBUF_UNAVA, ioaddr + AST_ETHER_IER);
+		outl(inl(ioaddr + AST_ETHER_IER) | ISR_RPKT_LOST, ioaddr + AST_ETHER_IER);
+		lasttbjiffy[dev->dev_id] = 0;
+		trans_busy[dev->dev_id] = 0;
+	}
+#endif
+	// --- Quanta
 }
 
 #ifdef CONFIG_ASTMAC100_NAPI
@@ -937,17 +1182,34 @@
 	}
 
 	if (status & ISR_RXBUF_UNAVA){
+		printk("ISR_RXBUF_UNAVA\n"); // Quanta
 		reg_value = inl(ioaddr + AST_ETHER_IER);
 		reg_value &= ~(ISR_RXBUF_UNAVA);
 		outl(reg_value, ioaddr + AST_ETHER_IER);
 #ifdef BROADCAST_BLACKLIST
 		ast_ether_bc[dev->dev_id].trans_busy_1 = 1 ;
 #endif
+		// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+		lasttbjiffy[dev->dev_id] = jiffies;
+		trans_busy[dev->dev_id] = 1;
+#endif
+		// --- Quanta
 	}
 	if (status & ISR_RPKT_LOST){
+		// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+		if ((pktlost_count[dev->dev_id] % 8) == 0)
+			printk("ISR_RPKT_LOST\n");
+
+		pktlost_count[dev->dev_id]++;
+//#else
+		// --- Quanta
 		reg_value = inl(ioaddr + AST_ETHER_IER);
 		reg_value &= ~(ISR_RPKT_LOST);
 		outl(reg_value, ioaddr + AST_ETHER_IER);
+#endif // Quanta
+
 #ifdef BROADCAST_BLACKLIST
 		ast_ether_bc[dev->dev_id].trans_busy_2 = 1 ;
 #endif
@@ -985,11 +1247,17 @@
 
 	ast_ether_init_descriptor(dev);
 	ast_ether_up(dev);
-
+	// Quanta start
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	init_bcs_timer(dev);
+	init_aspeed_mac_timer(dev);
+#endif
+	// Quanta end
 	netif_start_queue(dev);
 
 
     priv = netdev_priv(dev);
+	priv->link_state = -1; // Quanta
 #ifdef CONFIG_ASTMAC100_NAPI
        napi_enable(&priv->napi); 
 #endif
@@ -1015,6 +1283,13 @@
 
 	if (priv->timer.function != NULL)
 	    del_timer_sync(&priv->timer);
+
+	// Quanta start
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	del_timer_sync(&bcs_timer[dev_id]);
+	del_timer_sync(&update_mac_timer[dev_id]);
+#endif
+	// Quanta end
 	
 	init_timer(&priv->timer);
 	priv->timer.data = (unsigned long)dev;
@@ -1358,6 +1633,15 @@
 
 	outl(AST_SCU_UNLOCK_MAGIC, SCU_KEY_CONTROL_REG); /* unlock SCU */
 
+	// Quanta start
+	/* enable the reset */
+	reg = inl(SCU_SYS_RESET_REG);
+	reg |= (AST_SCU_RESET_MAC1 | AST_SCU_RESET_MAC2);
+	outl(reg, SCU_SYS_RESET_REG);
+
+	udelay(100);
+	// Quanta end
+
 	/* enable clcok */
 	reg = inl(SCU_CLK_STOP_REG);
 	reg &= ~(AST_SCU_CLK_STOP_MAC1 | AST_SCU_CLK_STOP_MAC2);
