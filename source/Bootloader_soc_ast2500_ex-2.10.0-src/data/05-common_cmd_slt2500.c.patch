--- uboot/common/cmd_slt2500.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot/common/cmd_slt2500.c.new	2016-10-04 20:18:31.783634547 +0800
@@ -0,0 +1,188 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <edid.h>
+#include <environment.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#include <linux/compiler.h>
+
+#define TIMEOUT_DRAM              5000000
+#define DRAM_MapAdr               (CONFIG_SYS_SDRAM_BASE + 1000000)
+#define MEM_BOUND                 16
+
+#if 1
+  #define WriteSOC_DD(a,b)          *((unsigned long *)a)=(unsigned long)b
+#else
+  void WriteSOC_DD(unsigned long a,unsigned long b) 
+  {
+    *((unsigned long *)a)=(unsigned long)b;
+  }
+#endif
+
+#define ReadSOC_DD(a)             *((unsigned long *)a)
+
+/* ------------------------------------------------------------------------- */
+int MMCTestBurst(unsigned int datagen)
+{
+  unsigned int data;
+  unsigned int timeout = 0;
+  
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  WriteSOC_DD( 0x1E6E0070, (0x000000C1 | (datagen << 3)) );
+  
+  do {
+    data = ReadSOC_DD( 0x1E6E0070 ) & 0x3000;
+
+    if( data & 0x2000 )
+      return(0);
+
+    if( ++timeout > TIMEOUT_DRAM ) {
+      printf("Timeout!!\n");
+      WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+      
+      return(0);
+    }
+    udelay(10);
+  } while( !data );
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  
+  return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int MMCTestSingle(unsigned int datagen)
+{
+  unsigned int data;
+  unsigned int timeout = 0;
+
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  WriteSOC_DD( 0x1E6E0070, (0x00000085 | (datagen << 3)) );
+  
+  do {
+    data = ReadSOC_DD( 0x1E6E0070 ) & 0x3000;
+    
+    if( data & 0x2000 )
+      return(0);
+    
+    if( ++timeout > TIMEOUT_DRAM ){
+      printf("Timeout!!\n");
+      WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+      
+      return(0);
+    }
+    udelay(10);
+  } while ( !data );
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  
+  return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int MMCTest(unsigned int testSize)
+{
+    unsigned int pattern;
+    int i;
+
+    pattern = ReadSOC_DD(0x1E6E2078);
+    printf("Pattern = %08X : ", pattern);
+
+    for (i = 0; i < testSize; i += MEM_BOUND) {
+        if (i > 0)
+            printf(".");
+
+        WriteSOC_DD(0x1E6E0074, ((DRAM_MapAdr + 0x100000 * i) | 0xfffff0));
+        WriteSOC_DD(0x1E6E007C, pattern);
+
+        if(!MMCTestBurst(0))    return(0);
+        if(!MMCTestBurst(1))    return(0);
+        if(!MMCTestBurst(2))    return(0);
+        if(!MMCTestBurst(3))    return(0);
+        if(!MMCTestBurst(4))    return(0);
+        if(!MMCTestBurst(5))    return(0);
+        if(!MMCTestBurst(6))    return(0);
+        if(!MMCTestBurst(7))    return(0);
+        if(!MMCTestSingle(0))   return(0);
+        if(!MMCTestSingle(1))   return(0);
+        if(!MMCTestSingle(2))   return(0);
+        if(!MMCTestSingle(3))   return(0);
+        if(!MMCTestSingle(4))   return(0);
+        if(!MMCTestSingle(5))   return(0);
+        if(!MMCTestSingle(6))   return(0);
+        if(!MMCTestSingle(7))   return(0);
+    }
+
+    return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int dram_stress_function(int argc, char * const argv[])
+{
+    unsigned int PassCnt     = 0;
+    unsigned int Testcounter = 0;
+    unsigned int MemSize = 32;  // 32MB
+    unsigned int ArgMemSize = 0;
+    int          ret = 1;
+
+    printf("**************************************************** \n");
+    printf("*** ASPEED Stress DRAM                           *** \n");
+    printf("***                          20131107 for u-boot *** \n");
+    printf("*** Usage: dramtest [loop] (mem_size)            *** \n");
+    printf("***    ex: dramtest 10 128                       *** \n");
+    printf("**************************************************** \n");
+    printf("\n");
+  
+    if ( argc < 2 ) {
+        ret = 0;
+        return ( ret );
+    }
+    else {
+        Testcounter = (unsigned int) simple_strtoul(argv[1], NULL, 10);
+
+        if (argc > 2) {
+            ArgMemSize = (unsigned int)simple_strtoul(argv[2], NULL, 10);
+            if (ArgMemSize > MemSize) {
+                MemSize = (ArgMemSize%MEM_BOUND) ? (ArgMemSize/MEM_BOUND + 1)*MEM_BOUND : ArgMemSize;
+            }
+        }
+        printf("Test region: 16MB ~ %dMB\n", MemSize);
+    }
+
+    WriteSOC_DD(0x1E6E0000, 0xFC600309);   
+
+    while( ( Testcounter > PassCnt ) || ( Testcounter == 0 ) ){
+        if (!MMCTest(MemSize - 16)) {
+            printf("FAIL...%d/%d\n", PassCnt, Testcounter);
+            ret = 0;
+      
+            break;
+        }
+        else {
+            PassCnt++;
+            printf("Pass %d/%d\n", PassCnt, Testcounter);
+        }
+     } // End while()
+     
+     return( ret );
+}
+
+static int do_dramtest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    return dram_stress_function( argc, argv);
+}
+
+U_BOOT_CMD(
+    dramtest,   10, 0,  do_dramtest,
+    "dramtest- Stress DRAM",
+    NULL
+);
