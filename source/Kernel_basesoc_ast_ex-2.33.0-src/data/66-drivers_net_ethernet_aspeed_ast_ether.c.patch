--- linux/drivers/net/ethernet/aspeed/ast_ether.c	2017-03-10 21:12:57.441202679 +0800
+++ linux/drivers/net/ethernet/aspeed/ast_ether_1G.c	2017-03-10 21:22:07.353061069 +0800
@@ -60,6 +60,111 @@
 static void ast_ether_free_rx_buf(struct net_device *dev);
 //int phy_ad = 0 ;
 
+// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+#ifdef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+#define BORADCAST_MSG_ENABLED 0
+#define BORADCAST_CHECKING_NUM 3840
+#define TIME_4K (HZ*BORADCAST_CHECKING_NUM/4000)
+#define TIME_6K (HZ*BORADCAST_CHECKING_NUM/6000)
+#define TIME_8K (HZ*BORADCAST_CHECKING_NUM/8000)
+#define TIME_10K (HZ*BORADCAST_CHECKING_NUM/10000)
+#define FILTER_TIME_4K (TIME_4K * 1 / 4)
+#define FILTER_TIME_6K (TIME_6K * 2 / 3)
+#define FILTER_TIME_8K (TIME_8K * 3 / 2)
+#define FILTER_TIME_10K (TIME_10K * 4 / 1)
+int filter_on_time =  0;
+#endif
+
+static unsigned int trans_busy[AST_ETHER_USE_NUM] = {0};
+static unsigned long lasttbjiffy[AST_ETHER_USE_NUM] = {0};
+static unsigned int pktlost_count[AST_ETHER_USE_NUM] = {0};
+static unsigned long lastjiffy[AST_ETHER_USE_NUM] = {0};
+static unsigned long lastjiffycount[AST_ETHER_USE_NUM] = {0};
+static unsigned long firstbcjiffy[AST_ETHER_USE_NUM] = {0};
+static struct timer_list bcs_timer[AST_ETHER_USE_NUM];
+static struct timer_list update_mac_timer[AST_ETHER_USE_NUM]; 
+static unsigned long bcs_assert_jiffy[AST_ETHER_USE_NUM] = {0};
+
+static void broadcast_storm_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device*)data;
+	struct ast_ether_priv *priv;
+	priv = netdev_priv((struct net_device *)data);
+
+#ifndef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+	if ((lastjiffy[priv->idx] != 0) && ((jiffies - lastjiffy[priv->idx]) >= (2 * HZ))) {
+		unsigned int ioaddr = dev->base_addr;
+
+		printk("%s: Enable RX_HT, RX_MULTIPKT, RX_BROADPKT\n", dev->name);
+		lastjiffy[priv->idx] = 0;
+		lastjiffycount[priv->idx] = 0;
+		outl(inl(ioaddr + AST_ETHER_MACCR) | MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN, ioaddr + AST_ETHER_MACCR);
+	}
+	
+	if(jiffies - bcs_assert_jiffy[priv->idx] >= (5*HZ)){	
+		priv->bcs_flag = 0x0; //No BCS over 5 sec, set the flag 0x0. 
+	}
+	
+	bcs_timer[priv->idx].expires = jiffies + (1 * HZ);
+	add_timer(&bcs_timer[priv->idx]);
+#else
+	if ((lastjiffy[priv->idx] != 0) && ((jiffies - lastjiffy[priv->idx]) >= (filter_on_time))) {
+		unsigned int ioaddr = dev->base_addr;
+		if (BORADCAST_MSG_ENABLED)
+			printk("%s: Enable Broadcast\n", dev->name);
+		lastjiffy[priv->idx] = 0;
+		lastjiffycount[priv->idx] = 0;
+		outl(inl(ioaddr + AST_ETHER_MACCR) | MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN, ioaddr + AST_ETHER_MACCR);
+
+		filter_on_time = 0;
+	}
+
+	if(jiffies - bcs_assert_jiffy[priv->idx] >= (5*HZ)){	
+		priv->bcs_flag = 0x0; //No BCS over 5 sec, set the flag 0x0. 
+	}
+
+	bcs_timer[priv->idx].expires = jiffies + (HZ/10);
+	add_timer(&bcs_timer[priv->idx]);
+#endif
+// --- Quanta Chin-Te added 20150910
+}
+
+static void init_bcs_timer(struct net_device *dev)
+{
+	struct ast_ether_priv *priv;
+	priv = netdev_priv(dev);
+	init_timer(&bcs_timer[priv->idx]);
+	bcs_timer[priv->idx].data = (unsigned long)dev;
+	bcs_timer[priv->idx].function = broadcast_storm_timer;
+	bcs_timer[priv->idx].expires = jiffies + (1 * HZ);
+	add_timer(&bcs_timer[priv->idx]);
+}
+
+static void aspeed_mac_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device*)data;
+	struct ast_ether_priv *priv;
+	priv = netdev_priv((struct net_device *)data);
+
+	outl(0xffffffff, dev->base_addr + AST_ETHER_TXPD); /* Trigger an Tx Poll demand */
+	update_mac_timer[priv->idx].expires = jiffies + (1 * HZ);
+	add_timer(&update_mac_timer[priv->idx]);
+}
+
+static void init_aspeed_mac_timer(struct net_device *dev)
+{
+	struct ast_ether_priv *priv;
+	priv = netdev_priv(dev);
+	init_timer(&update_mac_timer[priv->idx]);
+	update_mac_timer[priv->idx].data = (unsigned long)dev;
+	update_mac_timer[priv->idx].function = aspeed_mac_timer;
+	update_mac_timer[priv->idx].expires = jiffies + (1 * HZ);
+	add_timer(&update_mac_timer[priv->idx]);
+}
+#endif
+// --- Quanta
+
 static void ast_ether_get_hardware_addr(struct net_device* dev)
 {
 	struct ast_ether_priv *priv;
@@ -74,9 +179,9 @@
 
 	count = 0;
 	while (inl(ioaddr + AST_ETHER_PHYCR) & (PHYCR_READ | PHYCR_WRITE)) {
-		mdelay(10);
+		udelay(10);//mdelay(10); //Quanta++, avoide spin_lock too long time
 		count ++;
-		if (count > 100)
+		if (count > 100000/*100*/) //Quanta++
 			break;
 	}
 }
@@ -142,11 +247,54 @@
 	switch (priv->phy_oui) 
 	{
 		case MARVELL_88E1111_OUI:
+//Quanta------
+      // S63 Marvell 88E1512 PHY RGMII TX/RX timing disabled.
+      switch (priv->phy_model) {
+         case 0x1D:  //88E1512  
+            ast_ether_phy_write_register(dev, priv->phy_addr, 22, 0x0002);   //switch to page 2
+            reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 21);  //Read MSCR2
+            reg_val = reg_val & 0xFFCF;                                      //Clear TX/RX timing control
+            ast_ether_phy_write_register(dev, priv->phy_addr, 21, reg_val);  
+            ast_ether_phy_write_register(dev, priv->phy_addr, 22, 0x0000);   //switch to page 0
+            ast_ether_phy_write_register(dev, priv->phy_addr, 0, 0x9140);    //Do the software reset
+            break;
+        }
+      break;
+//------Quanta	
+
 		case BROADCOM_BCM5221_OUI:
 		case BROADCOM_BCM5241_OUI:
 		case MICREL_KSZ80X1_OUI:
 		case REALTEK_RTL82X1X_OUI:
+//Quanta------
+        	/* S4E for LED configuration */
+        	/* switch to extend page44, reg31 = 0x0007 */
+        	ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0007);
+        	/* reg30 = 0x002c (44) */
+        	ast_ether_phy_write_register(dev, priv->phy_addr, 30, 0x002c);
+        	/* LED0 is for activity reg26 bit 4 = 1*/
+        	/* LED1 is 100M LED reg28 bit5 = 1, other bits = 0. */
+        	/* LED2 is 1000M LED reg28 bit10 =1, other bits = 0. */
+        	reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 28);
+        	reg_val = reg_val & 0xF000;
+        	reg_val = reg_val | 0x0420;
+        	ast_ether_phy_write_register(dev, priv->phy_addr, 28, reg_val);
+
+        	reg_val = ast_ether_phy_read_register(dev, priv->phy_addr, 26);
+        	reg_val = reg_val & 0xFF8F;
+        	reg_val = reg_val | 0x0010;
+        	ast_ether_phy_write_register(dev, priv->phy_addr, 26, reg_val);
+
+        	/* switch back to page 0, reg31=0x0000 */
+        	ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0000);
+	
+	  		/* S4E for LED configuration end */
+			break;
+		case SMSC_LAN9303_OUI:
+			// Quanta TBD       case 0x3fffff:
+			printk(">>>>> Phy Identified : SMSC_LAN9303_OUI\n");
 			break;
+//------Quanta	
 		case BROADCOM_BCM5421_OUI:
 		case BROADCOM_BCM5461_OUI:
 		case BROADCOM_BCM54612E_OUI:
@@ -389,6 +537,34 @@
 					break;
 				}
 				break;
+// Quanta ---
+			case SMSC_LAN9303_OUI:
+            //case 0x3fffff:
+				reg_val = ast_ether_phy_read_register(dev, 0, SMSC_LAN9303_REG_SPECIAL_CONTROL_STATUS);
+				switch ((reg_val & SMSC_LAN9303_REG_STATUS_MASK) >> SMSC_LAN9303_REG_STATUS_SHIFT) {
+				case SMSC_LAN9303_REG_STATUS_HALF_10:
+					duplex = PHY_DUPLEX_HALF;
+					speed = PHY_SPEED_10M;
+					break;
+				case SMSC_LAN9303_REG_STATUS_HALF_100:
+					duplex = PHY_DUPLEX_HALF;
+					speed = PHY_SPEED_100M;
+					break;
+				case SMSC_LAN9303_REG_STATUS_FULL_10:
+					duplex = PHY_DUPLEX_FULL;
+					speed = PHY_SPEED_10M;
+					break;
+				case SMSC_LAN9303_REG_STATUS_FULL_100:
+					duplex = PHY_DUPLEX_FULL;
+					speed = PHY_SPEED_100M;
+					break;
+				default:
+					duplex = PHY_DUPLEX_FULL;
+					speed = PHY_SPEED_100M;
+					break;
+				}
+				break;
+// --- Quanta
 			default:
 				speed = PHY_SPEED_100M;
 				duplex = 1;
@@ -779,6 +955,11 @@
 			wmb();
 			priv->rx_desc[entry].status &= RX_DESC_EDORR; /* clear all field except EDORR, return ownership to hardware */
 		}
+		// Quanta ---
+		else {
+			priv->rx_desc[entry].status &= RX_DESC_EDORR; /* clear all field except EDORR, return ownership to hardware */
+		}
+		// --- Quanta
 		priv->dirty_rx ++;
 	}
 }
@@ -792,10 +973,11 @@
     priv->cur_rx = 0;
 	priv->dirty_rx = 0;
 	for (i = 0; i < RX_DES_NUM; i++) {
-		priv->rx_desc[i].status = 0;
+		priv->rx_desc[i].status = RX_DESC_RXPKT_RDY;  //= 0;  // Quanta
 		wmb();		/* Make sure adapter sees owner change */
 		if (priv->rx_skbuff[i]) {
-            dma_unmap_single(NULL, priv->rx_skb_dma[i], priv->rx_skbuff[i]->len, DMA_TO_DEVICE);
+            //dma_unmap_single(NULL, priv->rx_skb_dma[i], priv->rx_skbuff[i]->len, DMA_TO_DEVICE);  // Quanta
+            dma_unmap_single(NULL, priv->rx_skb_dma[i], RX_BUF_SIZE, DMA_FROM_DEVICE);              // Quanta
             dev_kfree_skb_irq(priv->rx_skbuff[i]);
 
 		}
@@ -831,8 +1013,13 @@
 	unsigned int ioaddr = dev->base_addr;
 	unsigned int reg_value;
 #endif
+	// Quanta start
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	unsigned int ioaddr = dev->base_addr;
+#endif
+	// Quanta end
 
-	has_error = 0;
+	//has_error = 0;  // Quanta comment it
 	has_first = 0;
 
 	while ((priv->dirty_rx + RX_DES_NUM) != priv->cur_rx) {
@@ -841,6 +1028,7 @@
 		if (!(status & RX_DESC_RXPKT_RDY)) /* owned by hardware */
             break;
 
+		has_error = 0;  // Quanta
 		if (status & RX_DESC_FRS) { /* first frame of packet, check error */
 			has_first = 1;
 
@@ -869,18 +1057,27 @@
 #endif
 		}
 
-		skb = priv->rx_skbuff[entry];
+		// Quanta start
+		/*skb = priv->rx_skbuff[entry];
 		dma_unmap_single(NULL, priv->rx_skb_dma[entry], RX_BUF_SIZE, DMA_FROM_DEVICE);
 		priv->rx_skbuff[entry] = NULL;
-		priv->rx_skb_dma[entry] = 0;
+		priv->rx_skb_dma[entry] = 0;*/
+		// Quanta end
 
 		if (has_error) {
 			if (status & RX_DESC_CRC_ERR)
 				priv->stats.rx_crc_errors ++;
 			if (status & RX_DESC_FIFO_FULL)
 				priv->stats.rx_fifo_errors ++;
-			kfree_skb(skb);
+			//kfree_skb(skb);  //Quanta comment it
 		} else {
+			// Quanta ---
+			skb = priv->rx_skbuff[entry];
+			dma_unmap_single(NULL, priv->rx_skb_dma[entry], RX_BUF_SIZE, DMA_FROM_DEVICE);
+			priv->rx_skbuff[entry] = NULL;
+			priv->rx_skb_dma[entry] = 0;
+			// --- Quanta
+
 			pkt_len = (status & RX_DESC_VDBC) - 4; /* Omit the four octet CRC from the length. */
 			if (pkt_len > 1518) {
 				printk(KERN_WARNING "%s: Bogus packet size of %d (%#x).\n", dev->name, pkt_len, pkt_len);
@@ -901,6 +1098,78 @@
 #ifdef CONFIG_ASTMAC100_NAPI
 			netif_receive_skb(skb);
 #else
+			// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+			if ((skb->data != NULL) && (pkt_len > 20)) {
+				if (skb->pkt_type == PACKET_BROADCAST || skb->pkt_type == PACKET_MULTICAST) {
+					lastjiffycount[priv->idx]++;
+					if (lastjiffycount[priv->idx] == 1)
+						firstbcjiffy[priv->idx] = jiffies;
+				} else {
+#ifndef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+					lastjiffycount[priv->idx] = 0;
+#endif
+				}
+
+#ifndef CONFIG_QUANTA_BROADCAST_STORM_AMA_ONLY
+				if (lastjiffycount[priv->idx] >= 5000) {
+					if ((jiffies - firstbcjiffy[priv->idx]) < HZ) {
+						printk("%s: Disable RX_HT, RX_BROADPKT\n", dev->name);
+						outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+							ioaddr + AST_ETHER_MACCR);	
+						priv->bcs_flag = 0x1;
+						bcs_assert_jiffy[priv->idx] = jiffies;
+						lastjiffy[priv->idx] = jiffies;
+					}
+					lastjiffycount[priv->idx] = 0;
+				}
+#else
+				if (lastjiffycount[priv->idx] >= BORADCAST_CHECKING_NUM) {
+					if ((jiffies - firstbcjiffy[priv->idx]) < TIME_10K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[priv->idx] = jiffies;
+							filter_on_time  = FILTER_TIME_10K;
+							priv->bcs_flag = 0x1;
+							bcs_assert_jiffy[priv->idx] = jiffies;
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 10K broadcast PPS\n", dev->name);
+					}
+					else if ((jiffies - firstbcjiffy[priv->idx]) < TIME_8K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[priv->idx] = jiffies;
+							filter_on_time  = FILTER_TIME_8K;
+							priv->bcs_flag = 0x1;
+							bcs_assert_jiffy[priv->idx] = jiffies;							
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 8K broadcast PPS\n", dev->name);
+					}
+					else if ((jiffies - firstbcjiffy[priv->idx]) < TIME_6K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[priv->idx] = jiffies;
+							filter_on_time  = FILTER_TIME_6K;
+							priv->bcs_flag = 0x1;
+							bcs_assert_jiffy[priv->idx] = jiffies;							
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 6K broadcast PPS\n", dev->name);
+					}
+					else if ((jiffies - firstbcjiffy[priv->idx]) < TIME_4K) {
+							outl(inl(ioaddr + AST_ETHER_MACCR) & ~(MACCR_RX_HT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_BROADPKT_EN), 
+								ioaddr + AST_ETHER_MACCR);
+							lastjiffy[priv->idx] = jiffies;
+							filter_on_time  = FILTER_TIME_4K;
+							if (BORADCAST_MSG_ENABLED)
+								printk("%s: Disable Broadcast due to 4K broadcast PPS\n", dev->name);
+					}
+					lastjiffycount[priv->idx] = 0;
+				}
+#endif
+			}
+#endif // end CONFIG_QUANTA_BROADCAST_STORM
+			// --- Quanta
+
 			netif_rx(skb);
 #endif
 	
@@ -926,6 +1195,19 @@
 		outl(reg_value, ioaddr + AST_ETHER_IER);
 	} 
 #endif
+
+	// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	if (lastjiffy[priv->idx] != 0)
+		return;
+	if ((trans_busy[priv->idx] == 1) && ((jiffies - lasttbjiffy[priv->idx]) > (4 * HZ))) {
+		outl(inl(ioaddr + AST_ETHER_IER) | ISR_RXBUF_UNAVA, ioaddr + AST_ETHER_IER);
+		outl(inl(ioaddr + AST_ETHER_IER) | ISR_RPKT_LOST, ioaddr + AST_ETHER_IER);
+		lasttbjiffy[priv->idx] = 0;
+		trans_busy[priv->idx] = 0;
+	}
+#endif
+	// --- Quanta
 }
 
 #ifdef CONFIG_ASTMAC100_NAPI
@@ -980,17 +1262,34 @@
 	}
 
 	if (status & ISR_RXBUF_UNAVA){
+		//printk("ISR_RXBUF_UNAVA\n"); // Quanta
 		reg_value = inl(ioaddr + AST_ETHER_IER);
 		reg_value &= ~(ISR_RXBUF_UNAVA);
 		outl(reg_value, ioaddr + AST_ETHER_IER);
 #ifdef BROADCAST_BLACKLIST
 		ast_ether_bc[priv->idx].trans_busy_1 = 1 ;
 #endif
+		// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+		lasttbjiffy[priv->idx] = jiffies;
+		trans_busy[priv->idx] = 1;
+#endif
+		// --- Quanta
 	}
 	if (status & ISR_RPKT_LOST){
+		// Quanta ---
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+		if ((pktlost_count[priv->idx] % 8) == 0)
+			printk("ISR_RPKT_LOST\n");
+
+		pktlost_count[priv->idx]++;
+//#else
+		// --- Quanta
 		reg_value = inl(ioaddr + AST_ETHER_IER);
 		reg_value &= ~(ISR_RPKT_LOST);
 		outl(reg_value, ioaddr + AST_ETHER_IER);
+#endif // Quanta
+
 #ifdef BROADCAST_BLACKLIST
 		ast_ether_bc[priv->idx].trans_busy_2 = 1 ;
 #endif
@@ -1028,11 +1327,18 @@
 
 	ast_ether_init_descriptor(dev);
 	ast_ether_up(dev);
-
+	// Quanta start
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	init_bcs_timer(dev);
+	init_aspeed_mac_timer(dev);
+#endif
+	// Quanta end
 	netif_start_queue(dev);
 
 
     priv = netdev_priv(dev);
+	priv->link_state = -1; // Quanta
+	priv->bcs_flag = 0xFF; //Quanta
 #ifdef CONFIG_ASTMAC100_NAPI
        napi_enable(&priv->napi); 
 #endif
@@ -1046,8 +1352,9 @@
 	struct ast_ether_priv *priv;
     unsigned long flags;
 
-	dev_id = dev->dev_id;
+	//dev_id = dev->dev_id;//Quanta
 	priv = netdev_priv(dev);
+	dev_id = priv->idx;//Quanta
 
 #ifdef CONFIG_ASTMAC100_NAPI
        napi_disable(&priv->napi);
@@ -1058,6 +1365,13 @@
 
 	if (priv->timer.function != NULL)
 	    del_timer_sync(&priv->timer);
+
+	// Quanta start
+#ifdef CONFIG_QUANTA_BROADCAST_STORM
+	del_timer_sync(&bcs_timer[dev_id]);
+	del_timer_sync(&update_mac_timer[dev_id]);
+#endif
+	// Quanta end
 	
 	init_timer(&priv->timer);
 	priv->timer.data = (unsigned long)dev;
@@ -1151,7 +1465,9 @@
 	struct ast_ether_priv *priv = netdev_priv(dev);
 
 	if (dev->flags & IFF_PROMISC) {
+#if !defined(CONFIG_SPX_FEATURE_NCSI_MULTI_NODE_CX4)
 		priv->maccr |= MACCR_RX_ALLADR;
+#endif
 	} else if (dev->flags & IFF_ALLMULTI) {
 		priv->maccr |= MACCR_RX_MULTIPKT_EN;
 	} 
@@ -1525,6 +1841,8 @@
 	spin_lock_init(&priv->lock);
 	spin_lock_init(&priv->mii_lock);
 
+	priv->bcs_flag = 0xFF;//Quanta
+
 	priv->maccr = MACCR_CRC_APD | MACCR_RXMAC_EN | MACCR_TXMAC_EN | MACCR_RXDMA_EN | MACCR_TXDMA_EN | MACCR_RX_BROADPKT_EN | MACCR_RX_MULTIPKT_EN | MACCR_RX_RUNT;
 
 	ast_ether_alloc_descriptor(dev);
@@ -1552,7 +1870,7 @@
 #define AST_SCU_SET_MAC1_MULTI_PIN       0xC0000000
 #define AST_SCU_SET_MAC2_MULTI_PIN       0x00000004
 #define AST_SCU_UNLOCK_MAGIC             0x1688A8A8
-
+#if 0 //Quanta--
 void __init ast_ether_set_multipin(void)
 {
 	uint32_t reg;
@@ -1573,13 +1891,22 @@
 
 	return;
 }
-
+#endif
 void __init ast_ether_scu_init(void)
 {
 	uint32_t reg;
 
 	outl(AST_SCU_UNLOCK_MAGIC, SCU_KEY_CONTROL_REG); /* unlock SCU */
 
+	// Quanta start
+	/* enable the reset */
+	reg = inl(SCU_SYS_RESET_REG);
+	reg |= (AST_SCU_RESET_MAC1 | AST_SCU_RESET_MAC2);
+	outl(reg, SCU_SYS_RESET_REG);
+
+	udelay(100);
+	// Quanta end
+
 	/* enable clcok */
 	reg = inl(SCU_CLK_STOP_REG);
 	reg &= ~(AST_SCU_CLK_STOP_MAC1 | AST_SCU_CLK_STOP_MAC2);
@@ -1602,7 +1929,7 @@
 	int result, id;
 
 	ast_ether_scu_init();
-	ast_ether_set_multipin();
+	//ast_ether_set_multipin();//Quanta--
 
 	result = -ENODEV;
 
